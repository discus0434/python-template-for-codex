あなたはこのファイル内で"AGENT"と呼称される。AGENTはこのファイル内で記述されているルールやワークフローを遵守し、ユーザーの要望に応じて適切な行動を取る。

## ルール

AGENTは以下のコーディングルール（基本ルール、Pythonのルール、TDDのルール、テスト実行フロー）に従う。

### 基本ルール

- 何もやるにもまずは計画を立てる。要件の不明瞭な部分はユーザーに質問し、全てが明確になるまで計画を続ける。詳細は[仕様追加・変更のライフサイクル](#仕様追加・変更のライフサイクル)を参照。
- 必ずTDDを行う。詳細は[TDDのルール](#tddのルール)と[テスト実行フロー](#テスト実行フロー)を参照。
- 思考や行動を英語で行い、ユーザーとの会話、Issue / PR コメントは日本語で行う（レビュー時の指摘・質問を含む）。
- PRの作成、コメントの確認、返信などの操作に `gh` コマンドを利用する。
- 無駄なフォールバックを記述しない。潔くエラーをraiseする。
- コードベースは小さく保ち、必要なものだけを書く。より読みやすく、テストしやすくなるようにする。
- 複雑なロジックは分解する。関数は小さく、目的が明確な、名前の良いものを書く。

### Pythonのルール

- Pythonの依存関係管理と実行に uv コマンドを利用する。`uv sync` で環境を構築し、スクリプト実行は `uv run xxx.py ...` のように行う。
- コードの可読性維持のため、Python の import 文は原則ファイル冒頭にまとめ、関数内での遅延 import は行わない。
- Pythonのバージョンは3.12を想定し、型アノテーションをそれに合わせる。
  - 例えば、`typing.Dict[Key, Value]` ではなく `dict[Key, Value]` を使用する。
  - `from __future__ import annotations` は不要なので記述しない。
- `make post-change` で ruff の format と lint、pytest をまとめて実行できる。AGENTは、Python ファイルの編集後、このコマンドを実行してエラーメッセージを確認し、エラーが出なくなるまでデバッグ・修正する。
- データモデルの定義に Pydantic を利用する。

### TDDのルール

- **TDD**: 仕様追加・変更時に必ず先んじてテストを書く。まず失敗するテストを書き、テストが通る最小限の実装をして、最後に重複や複雑さをリファクタで整理する。
- **カバレッジ**: 非テストコードを触ったときに、明らかなリネーム等を除いて、変更した挙動を通すテストを同じPRに必ず追加/更新する。
- **分岐**: 条件分岐がある場合は、到達可能な true/false（else/default）を必ず両方テストする。
- **ケース**: 各変更点に対し正常系を最低1つ、実装が明示的に扱うエラー/境界/空/NotFound/権限なども最低1つ書く。
- **アサーション**: 「落ちない」ではなく、戻り値・状態変化・副作用・例外の型/メッセージを具体的に検証する。
- **実行**: 変更後は必ずテストを実行する（手順は[テスト実行フロー](#テスト実行フロー)）。

### その他のルール

#### TODO更新ルール

- プランに記載したTODOは「開始/完了/中断」の節目で更新する（開始→in_progress、完了→done、中断→blocked/hold+理由1行）。
- ユーザーに制御を返す前に、最低1回はTODOの状態を最新化する。
- 2ターン以上かかりそうなTODOは、可能なら分割して追跡する。

#### 1ターンの長さに関するルール

- 基本的にはユーザーに制御を返さずに自走するが、**ユーザー判断が必要になった時点で制御を返す**（追加質問や選択肢提示までを1ターンに含める）。
- ユーザーの判断が不要ならどんどん進めても良いが、プランの実行が完了し、ドキュメントの更新を始める前には必ず制御を返すようにする。
- 途中経過のみで返さず、結果＋次の問い/選択肢まで示す。

#### テスト実行フロー

- Pythonファイルを編集した場合は必ず `make post-change` を実行し、format・lint・pytest をまとめて回す。
- 追加で確認したい範囲がある場合は `make test -k "<pattern>"` で対象を絞って実行する。
- テストが失敗したら、該当箇所を修正し、同じコマンドを再実行し、エラーが消えるまで繰り返す。
- 環境依存など自力で解決困難な場合は、ユーザーへの確認・アクション依頼を行う。

#### セルフレビュー（plan-reviewer）

- 実装が一通り終わったら、docs更新に入る前に **plan-reviewer** を使ってセルフレビューする。
- プランの「確定事項/設計/タスク」と現コード・テストの一致を確認し、不足/乖離は修正する。
- 判断が必要なズレが出た場合はユーザーに確認を戻す。

## ドキュメント

AGENTは、ドキュメントを以下のように記述する。

- `docs/` に現況を反映したドキュメントを記述していく。
- `docs/` 下のドキュメントは確定した仕様のみを記述する。これから実装予定の内容は `plans/` に記述するべきである。
- 仕様変更・追加・修正があったら必ず更新し、全て最新の状態を保つ。
- `docs/CHANGELOG.md` を除き、ドキュメントに追加・修正を入れる際は既存の内容を上書きして更新し、追記や補足という形式での更新を避ける。履歴は残さず常に現況を示す。
- 変更履歴は `docs/CHANGELOG.md` に記録する。関連するPRやIssueがあれば併記する。
- `docs/REQUIREMENTS.md` に要求仕様を記述する。
- `docs/DESIGN.md` にDesign Docを記述する。Design Docには以下の内容を記述する。
    - アーキテクチャ概要
    - アーキテクチャの詳細
    - データモデル、データフローなど
    - 各モジュールの概要
    - 各モジュールの内部仕様・処理フローなど
- その他、より詳細な設計・実装に関するドキュメントを `docs/` 下に追加していく。

## 仕様追加・変更のライフサイクル

- AGENTは、仕様追加・変更の計画時、ユーザーとの対話を通じて `plans/` 下にプランを記述していく。
- プランの粒度は「実装・テスト・ドキュメント更新を含めて1〜2営業日以内で完了するサイズ」を上限とする。これを超えそうな場合は分割し、フェーズごとにプランを作成する。
- リスクが高い変更（例: DBスキーマ変更、認証・課金・権限まわりの改修、大規模データ移行など）は、時間に収まっても単独プランとして扱う。
- プラン作成時は `plans/TEMPLATE.md` を雛形としてコピーし、必要事項を埋める。
- AGENTは、プランにある内容を実装し終えたら plan-reviewer でセルフレビューし、不足/乖離を解消してから、ユーザー承認→docs反映へ進む。
- つまり、AGENTの仕様追加・変更のライフサイクルは以下のようになる。
    1. ユーザーからの要望を受け取り、不明確な部分があればユーザーに質問し、全てが明確になるまでプランニングを続ける。
    2. プランニングが完了したら、`plans/` 下にプランを記述する。
    3. プランにある内容を実装する。[ルール](#ルール)に従ってTDDで実装を行い、テストを通す。
    4. plan-reviewer でセルフレビューし、プランとコード/テストの乖離を修正する。
    5. 実装が完了したら、ユーザーから承認を得る。承認を得たら、`plans/` 下からプランを削除し、`docs/` 下のドキュメントを更新し、変更概要を `docs/CHANGELOG.md` に追記する。
- ただし、AGENTはユーザーによってライフサイクルの途中で初期化される場合もある。その場合、AGENTはまず自分が今どの段階にいるかを判断してから、適切な行動を取る。
